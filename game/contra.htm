<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link rel="shortcut icon" href="https://ooyang.cn/favicon.ico" />
<title>é­‚æ–—ç½—1 | ç¦å·è€æ¨</title>
<meta name="title" content="é­‚æ–—ç½—1" />
<meta name="description" content="ã€Šé­‚æ–—ç½—ã€‹ï¼ˆContraï¼‰æ˜¯ç”±Konamiäº1987å¹´æ¨å‡ºçš„ä¸€ç³»åˆ—å·è½´å°„å‡»ç±»å•æœºæ¸¸æˆã€‚æ•…äº‹èƒŒæ™¯æ˜¯æ ¹æ®è‘—åææ€–ç‰‡ã€Šå¼‚å½¢ï¼ˆAlienï¼‰ã€‹æ”¹ç¼–ï¼Œäººç‰©åŸå‹æ¥æºäºè‘—åå½±æ˜Ÿæ–½ç“¦è¾›æ ¼å’Œå²æ³°é¾™ã€‚1987å¹´ç¬¬ä¸€æ¬¾é­‚æ–—ç½—è¯ç”Ÿåœ¨åä¸ºJammaçš„è¡—æœºä¸Šã€‚æ¸¸æˆåç§°çš„å«ä¹‰æ˜¯â€œå…·æœ‰ä¼˜ç§€æˆ˜æ–—èƒ½åŠ›å’Œç´ è´¨çš„äººâ€ï¼Œå®ƒæ˜¯èµ‹äºˆæœ€å¼ºæˆ˜å£«çš„ç§°å‘¼ã€‚ FCä¸Šçš„ä¸¤éƒ¨é­‚æ–—ç½—å½±å“äº†æ•´æ•´ä¸€ä»£æ¸¸æˆç©å®¶ï¼Œåœ¨å½“æ—¶ä¸ã€Šè¶…çº§é©¬é‡Œå¥¥ã€‹é½åï¼Œå‡ ä¹æˆä¸ºFCæ—¶ä»£ç”µå­æ¸¸æˆçš„ä»£åè¯ã€‚æ­¤å¤–KONAMIäº1989å¹´è¿˜åœ¨æ—¥å¼è®¡ç®—æœºMSX2ä¸Šæ¨å‡ºäº†å¤§å‹æ¸¸æˆæœºçš„åŒåç§»æ¤ç‰ˆã€‚â€œé­‚æ–—ç½—â€çš„å«ä¹‰æ˜¯â€œå…·æœ‰ä¼˜ç§€æˆ˜æ–—èƒ½åŠ›å’Œç´ è´¨çš„äººâ€ï¼Œå®ƒæ˜¯èµ‹äºˆæœ€å¼ºæˆ˜å£«çš„ç§°å‘¼ã€‚       é­‚æ–—ç½—æˆä¸ºäº†ç»å…¸ï¼Œå¾ˆå¤šå°„å‡»æ¸¸æˆéƒ½æˆä¸ºäº†é­‚æ–—ç½—ç±»æ¸¸æˆã€‚é­‚æ–—ç½—å¯¹åŠ¨ä½œå°„å‡»æ¸¸æˆçš„å½±å“æ˜¯ä¸å¯ä¼°é‡çš„ã€‚ä»¥è‡³äºåæ¥ä¼—æ‰€å‘¨çŸ¥çš„åŠ¨ä½œå°„å‡»åä½œã€Šåˆé‡‘å¼¹å¤´ã€‹åœ¨è®¾è®¡ä¸Šéƒ½å—åˆ°äº†æ¥è‡ªå½“å¹´ã€Šé­‚æ–—ç½—ã€‹çš„æ·±åˆ»å½±å“ï¼Œç‰¹åˆ«æ˜¯SNVCSä¸Šçš„ã€Šé­‚æ–—ç½—Â·å¼‚å½¢æˆ˜äº‰ã€‹ï¼Œä¸¤ä½œç›¸åŒçš„ç«çˆ†ç¨‹åº¦å’Œé‚£ä¼¼æ›¾ç›¸è¯†çš„å…³å¡ä¾¿å¯ä»¥çœ‹å‡ºã€Šé­‚æ–—ç½—ã€‹ä¸ºå°„å‡»æ¸¸æˆé¢†å¯¼äº†ä¸€åœºå…¨æ–°çš„æ¸¸æˆé©å‘½ã€‚" />
<meta name="keywords" content="Game," />
<link rel="stylesheet" type="text/css" href="/css/bearblog.css">

</head>
<body>
  <header>    <div class="overlay"></div>
	<a href="/" class="title" title="ç¦å·è€æ¨"><h1>OOyang</h1></a>
<nav><a href="/" title="é¦–é¡µ">Home</a><a href="/a" target="_blank" title="Websiteç½‘å€å¯¼èˆª">Navigation</a><a href="/posts" title="æ–‡ç« åˆ—è¡¨">Article</a><a href="/about" title="å…³äºæˆ‘ä»¬">About Us</a><a href="https://github.com/fzlaoyang/BBS/issues/1" target="_blank" title="è”ç³»æˆ‘ä»¬">Contact</a><hr></nav>
</header>
  <main>

<h2 style="text-align: center;">é­‚æ–—ç½—1</h2>

<content><style>
:root {--gap: 10px;}
.bar {display: flex;gap: var(--gap);align-items: center;flex-wrap: wrap;}
label.btn,
button,
a.btn {padding: 6px 10px;border: 1px solid #ddd;border-radius: 8px;background: #f7f7f7;cursor: pointer;text-decoration: none;color: #111;}
.btn-toggle.on {background: #e9f7ff;border-color: #9ad4ff;}
.status {color: #555}
.err {color: #b00020}
#stage {margin-top: 12px;display: grid;place-items: center;outline: none;position: relative;}
canvas {
  image-rendering: pixelated;
  border: 1px solid #eee;
  border-radius: 10px;
  box-shadow: 0 6px 20px rgba(0, 0, 0, .08);
  background: #000;
}
.group {display: flex;align-items: center;gap: 6px;}
select,
input[type="range"] {padding: 2px 4px;}
.crt::after {content: "";position: absolute;inset: 0;pointer-events: none;background: repeating-linear-gradient(to bottom, rgba(0, 0, 0, .15) 0, rgba(0, 0, 0, .15) 1px, transparent 2px, transparent 3px);
  mix-blend-mode: multiply;border-radius: 10px;}
.modal-backdrop {position: fixed;inset: 0;background: rgba(0, 0, 0, .4);display: none;align-items: center;  justify-content: center;z-index: 999;}
.modal {background: #fff;border-radius: 12px;box-shadow: 0 10px 40px rgba(0, 0, 0, .2);padding: 16px;max-width: 720px;  width: calc(100% - 32px);}
.modal h3 {margin: 0 0 8px}
.grid {display: grid;grid-template-columns: 1fr 1fr;gap: 8px;}
.row {display: flex;gap: 8px;align-items: center;justify-content: space-between;border: 1px dashed #eee;padding: 6px 8px;border-radius: 8px;}
.kbd {font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;background: #f3f3f3;border-radius: 6px;padding: 3px 6px;border: 1px solid #e5e5e5;}
.tip {color: #666;font-size: 12px;}
.modal .footer {display: flex;justify-content: flex-end;gap: 8px;margin-top: 10px;}
.drop-hint {position: fixed;inset: 0;display: none;align-items: center;justify-content: center;background: rgba(30, 144, 255, .12);border: 3px dashed #1e90ff;color: #1e90ff;font-weight: 600;font-size: 20px;z-index: 998;}
  </style>
  <div class="bar">
    <label class="btn">é€‰æ‹©ROM<input id="rom" type="file" accept=".nes" hidden></label>
	<a href="#" class="btn" id="demoRom" data-rom-url="contra.nes" data-rom-name="contra.nes">é­‚æ–—ç½—1</a>
    <a href="#" class="btn" id="demoRom" data-rom-url="tank.nes" data-rom-name="tank.nes">å¦å…‹</a>
    <a href="#" class="btn" id="demoRom" data-rom-url="1943.nes" data-rom-name="1943.nes">1943</a>
    <button id="toggle" disabled>å¼€å§‹</button>
    <button id="reset" disabled>å¤ä½</button>
    <div class="group">
      <button id="mute" class="btn-toggle">ğŸ”ˆ é™éŸ³</button>
      <label>éŸ³é‡ <input id="vol" type="range" min="0" max="100" value="100"></label>
      <button id="screenshot">ğŸ“· æˆªå›¾</button>
    </div>
    <div class="group">
      <label>æ˜¾ç¤ºå€æ•°
        <select id="scale">
          <option value="1">1Ã—</option>
          <option value="2" selected>2Ã—</option>
          <option value="3">3Ã—</option>
          <option value="4">4Ã—</option>
        </select>
      </label>
      <button id="fit">è‡ªé€‚åº”</button>
      <button id="fs">â›¶ å…¨å±</button>
      <button id="crt" class="btn-toggle">ğŸ“º CRT</button>
    </div>
    <div class="group">
      <label>é€Ÿåº¦
        <select id="speed">
          <option value="0.5">0.5Ã—</option>
          <option value="1" selected>1Ã—</option>
          <option value="2">2Ã—</option>
          <option value="3">3Ã—</option>
          <option value="4">4Ã—</option>
        </select>
      </label>
      <span class="tip">æŒ‰ä½ <span class="kbd">Tab</span> ä¸´æ—¶å¿«è¿›ï¼ˆÃ—2 å½“å‰é€Ÿåº¦ï¼Œæœ€é«˜ Ã—6ï¼‰</span>
    </div>
    <div class="group">
      <button id="swap" class="btn-toggle on">ğŸ¨ è‰²å½©ä¿®æ­£</button>
      <button id="cfgKeysP1">âŒ¨ï¸ P1 é”®ç›˜æ˜ å°„</button>
      <button id="cfgKeysP2">âŒ¨ï¸ P2 é”®ç›˜æ˜ å°„</button>
      <button id="cfgPadP1">ğŸ® P1 æ‰‹æŸ„æ˜ å°„</button>
      <button id="cfgPadP2">ğŸ® P2 æ‰‹æŸ„æ˜ å°„</button>
    </div>
    <div class="group">
      <label>å­˜æ¡£æ§½<select id="slot">
          <option value="0">#1</option>
          <option value="1">#2</option>
          <option value="2">#3</option>
        </select></label>
      <button id="saveState">ğŸ’¾ ä¿å­˜</button>
      <button id="loadState">ğŸ“‚ è¯»å–</button>
      <button id="clearState">ğŸ—‘ï¸ æ¸…é™¤</button>
      <button id="exportState">â¬‡ï¸ å¯¼å‡º</button>
      <label class="btn">å¯¼å…¥<input id="importState" type="file" accept=".json,.state.json,application/json" hidden></label>
    </div>
    <div class="group">
      <button id="recStart">âº å¼€å§‹å½•åˆ¶</button>
      <button id="recStop" disabled>â¹ åœæ­¢å½•åˆ¶</button>
      <a id="recDownload" style="display:none" download="recording.webm">â¬‡ï¸ ä¸‹è½½è§†é¢‘</a>
    </div>
    <span class="status" id="romName">æœªåŠ è½½</span>
    <span class="status" id="fps">FPS: --</span>
    <span class="err" id="err"></span>
  </div>
  <div id="stage" tabindex="0"><canvas id="screen" width="256" height="240"></canvas></div>
  <!-- é”®ç›˜æ˜ å°„ -->
  <div id="modalKeys" class="modal-backdrop">
    <div class="modal">
      <h3 id="keysTitle">é”®ç›˜æ˜ å°„</h3>
      <div class="grid" id="keyGrid"></div>
      <div class="tip">ç‚¹å‡»æŸé¡¹åæŒ‰ä½ æƒ³ç»‘å®šçš„é”®ï¼›æ˜ å°„ä¿å­˜åˆ°æµè§ˆå™¨ï¼ˆå„ç©å®¶ç‹¬ç«‹ï¼‰ã€‚</div>
      <div class="footer">
        <button id="restoreKeyDefault">æ¢å¤é»˜è®¤</button>
        <button id="closeKeys">å…³é—­</button>
      </div>
    </div>
  </div>
  <!-- æ‰‹æŸ„æ˜ å°„ -->
  <div id="modalPad" class="modal-backdrop">
    <div class="modal">
      <h3 id="padTitle">æ‰‹æŸ„æ˜ å°„</h3>
      <div class="tip">è¿æ¥æ‰‹æŸ„åç‚¹â€œæ•æ‰â€å¹¶æŒ‰ä¸‹æ‰‹æŸ„æŒ‰é’®/æ–¹å‘ï¼›P1=æ‰‹æŸ„0ï¼ŒP2=æ‰‹æŸ„1ã€‚</div>
      <div id="padGrid"></div>
      <div class="footer">
        <button id="restorePadDefault">æ¢å¤é»˜è®¤</button>
        <button id="closePad">å…³é—­</button>
      </div>
    </div>
  </div>
  <div id="dropHint" class="drop-hint">æ‹–æ”¾ .nes æˆ– .state.json åˆ°æ­¤</div>
  <script src="https://unpkg.com/jsnes/dist/jsnes.min.js"></script>
  <script>
    (function() {
      // ------- DOM -------
      const stage = document.getElementById('stage');
      const canvas = document.getElementById('screen'),
        ctx = canvas.getContext('2d');
      const romNameEl = document.getElementById('romName'),
        fpsEl = document.getElementById('fps'),
        errEl = document.getElementById('err');
      const romInput = document.getElementById('rom');
      const btnStart = document.getElementById('toggle'),
        btnReset = document.getElementById('reset');
      const btnMute = document.getElementById('mute'),
        volEl = document.getElementById('vol');
      const scaleSel = document.getElementById('scale'),
        fitBtn = document.getElementById('fit'),
        fsBtn = document.getElementById('fs');
      const btnSwap = document.getElementById('swap'),
        btnCrt = document.getElementById('crt'),
        btnShot = document.getElementById('screenshot');
      const speedSel = document.getElementById('speed');
      const slotSel = document.getElementById('slot'),
        saveBtn = document.getElementById('saveState'),
        loadBtn = document.getElementById('loadState'),
        clearBtn = document.getElementById('clearState');
      const exportBtn = document.getElementById('exportState'),
        importInp = document.getElementById('importState');
      const recStartBtn = document.getElementById('recStart'),
        recStopBtn = document.getElementById('recStop'),
        recDL = document.getElementById('recDownload');
      const modalKeys = document.getElementById('modalKeys'),
        keyGrid = document.getElementById('keyGrid'),
        keysTitle = document.getElementById('keysTitle'),
        restoreKeyDefault = document.getElementById('restoreKeyDefault'),
        closeKeys = document.getElementById('closeKeys');
      const modalPad = document.getElementById('modalPad'),
        padGrid = document.getElementById('padGrid'),
        padTitle = document.getElementById('padTitle'),
        restorePadDefault = document.getElementById('restorePadDefault'),
        closePad = document.getElementById('closePad');
      const dropHint = document.getElementById('dropHint');
      // ------- NES & çŠ¶æ€ -------
      let nes = null,
        running = false,
        rafId = null;
      let pausedByVisibility = false,
        warmResumedOnce = false;
      const imageData = new ImageData(new Uint8ClampedArray(256 * 240 * 4), 256, 240);
      let swapRB = true;
      const AC = window.AudioContext || window.webkitAudioContext;
      let audioCtx = null,
        proc = null,
        qL = [],
        qR = [],
        muted = false,
        volume = 1.0;
      const SAMPLES = 512; // æ—§è®¾å¤‡å¯æ”¹å› 1024
      let mediaDest = null,
        mediaStream = null,
        recorder = null,
        recChunks = [];
      let lastRomU8 = null,
        lastRomStr = null; // å½“å‰æ¸¸æˆçš„ä¸¤ç§å­˜å‚¨å½¢å¼
      let frames = 0,
        lastTS = performance.now(),
        speed = 1,
        turboHeld = false,
        lastMult = 1,
        frameAcc = 0;
      // åˆ†å¸§é¢„çƒ­ & é˜Ÿåˆ—é™æµ
      let warming = false;
      const MAX_QUEUE = 16384;
      const WARMUP_TOTAL = 48;
      // ------- è¾“å…¥æ˜ å°„ -------
      const C = window.jsnes.Controller;
      const NES_BUTTONS = [
        ['ä¸Š', C.BUTTON_UP],
        ['ä¸‹', C.BUTTON_DOWN],
        ['å·¦', C.BUTTON_LEFT],
        ['å³', C.BUTTON_RIGHT],
        ['A', C.BUTTON_A],
        ['B', C.BUTTON_B],
        ['SELECT', C.BUTTON_SELECT],
        ['START', C.BUTTON_START]
      ];
      const defaultKeyMapP1 = {
        UP: 'ArrowUp',
        DOWN: 'ArrowDown',
        LEFT: 'ArrowLeft',
        RIGHT: 'ArrowRight',
        A: 'KeyZ',
        B: 'KeyX',
        SELECT: 'ShiftLeft',
        START: 'Enter'
      };
      const defaultKeyMapP2 = {
        UP: 'KeyW',
        DOWN: 'KeyS',
        LEFT: 'KeyA',
        RIGHT: 'KeyD',
        A: 'KeyK',
        B: 'KeyJ',
        SELECT: 'ShiftRight',
        START: 'Backspace'
      };
      let keyMapP1 = loadJSON('jsnes_keymap_p1', defaultKeyMapP1);
      let keyMapP2 = loadJSON('jsnes_keymap_p2', defaultKeyMapP2);
      let pressedP1 = new Set(),
        pressedP2 = new Set();
      const defaultPadMap = {
        AXIS_H: 0,
        AXIS_V: 1,
        AXIS_THRESH: 0.4,
        BTN_A: 0,
        BTN_B: 1,
        ALT_A: 2,
        ALT_B: 3,
        BTN_SELECT: 8,
        BTN_START: 9,
        DPAD_UP: 12,
        DPAD_DOWN: 13,
        DPAD_LEFT: 14,
        DPAD_RIGHT: 15
      };
      let padMapP1 = loadJSON('jsnes_padmap_p1', defaultPadMap);
      let padMapP2 = loadJSON('jsnes_padmap_p2', defaultPadMap);
      let padPrevP1 = stateObj(false),
        padPrevP2 = stateObj(false);
      const STATE_PREFIX = 'jsnes_state_slot_';

      function stateObj(v) {
        return {
          UP: v,
          DOWN: v,
          LEFT: v,
          RIGHT: v,
          A: v,
          B: v,
          SELECT: v,
          START: v
        };
      }

      function isNon1x() {
        return turboHeld || speed !== 1;
      }

      function clearAudioQueue() {
        qL.length = 0;
        qR.length = 0;
      }

      function toast(msg) {
        errEl.textContent = msg;
        setTimeout(() => {
          if (errEl.textContent === msg) errEl.textContent = '';
        }, 2000);
      }

      function loadJSON(k, def) {
        try {
          const v = localStorage.getItem(k);
          return v ? JSON.parse(v) : def;
        } catch {
          return def;
        }
      }

      function saveJSON(k, obj) {
        try {
          localStorage.setItem(k, JSON.stringify(obj));
        } catch {}
      }
      // ------- åˆ†å¸§é¢„çƒ­ -------
      function warmUpFrames(total = WARMUP_TOTAL, perTick = 8, done) {
        let left = total;

        function tick() {
          const n = Math.min(perTick, left);
          try {
            for (let i = 0; i < n; i++) nes.frame();
          } catch (e) {
            console.warn('warmup error:', e);
            left = 0;
          }
          left -= n;
          if (left > 0) requestAnimationFrame(tick);
          else if (typeof done === 'function') done();
        }
        requestAnimationFrame(tick);
      }
      // ------- é‡å»ºéŸ³é¢‘é“¾ -------
      function rebuildAudioGraph() {
        try {
          proc && proc.disconnect();
        } catch {}
        if (!mediaDest) {
          mediaDest = audioCtx.createMediaStreamDestination();
        }
        proc = audioCtx.createScriptProcessor(SAMPLES, 0, 2);
        proc.onaudioprocess = (e) => {
          const L = e.outputBuffer.getChannelData(0);
          const R = e.outputBuffer.getChannelData(1);
          const g = muted ? 0 : volume;
          for (let i = 0; i < L.length; i++) {
            const sl = qL.length ? qL.shift() : 0;
            const sr = qR.length ? qR.shift() : 0;
            L[i] = sl * g;
            R[i] = sr * g;
          }
        };
        proc.connect(audioCtx.destination);
        proc.connect(mediaDest);
        for (let i = 0; i < 2048; i++) {
          qL.push(0);
          qR.push(0);
        }
      }
      // ------- è¯»å–å­˜æ¡£åçš„æ¢å¤ -------
      function afterStateRestore() {
        const wasRunning = running;
        if (wasRunning) {
          running = false;
          if (rafId) cancelAnimationFrame(rafId);
          rafId = null;
        }
        turboHeld = false;
        speed = 1;
        speedSel.value = '1';
        if (muted) {
          muted = false;
          btnMute.classList.remove('on');
          btnMute.textContent = 'ğŸ”ˆ é™éŸ³';
        }
        clearAudioQueue();
        try {
          const p = audioCtx?.resume?.();
          if (p && typeof p.then === 'function') {
            p.then(() => rebuildAudioGraph());
          } else {
            rebuildAudioGraph();
          }
        } catch {
          rebuildAudioGraph();
        }
        warming = true;
        frames = 0;
        lastTS = performance.now();
        frameAcc = 0;
        warmUpFrames(WARMUP_TOTAL, 8, () => {
          clearAudioQueue();
          warming = false;
          if (wasRunning) {
            running = true;
            rafId = requestAnimationFrame(loop);
            btnStart.textContent = 'æš‚åœ';
            btnReset.disabled = false;
          }
        });
      }
      // ------- åˆå§‹åŒ– -------
      function init() {
        nes = new window.jsnes.NES({
          onFrame(buf) {
            const d = imageData.data;
            let j = 0;
            for (let i = 0; i < 256 * 240; i++) {
              const px = buf[i] >>> 0;
              if (swapRB) {
                d[j++] = px & 255;
                d[j++] = (px >> 8) & 255;
                d[j++] = (px >> 16) & 255;
              } else {
                d[j++] = (px >> 16) & 255;
                d[j++] = (px >> 8) & 255;
                d[j++] = px & 255;
              }
              d[j++] = 255;
            }
            ctx.putImageData(imageData, 0, 0);
            frames++;
            const now = performance.now();
            if (now - lastTS >= 1000) {
              fpsEl.textContent = `FPS: ${(frames*1000/(now-lastTS)).toFixed(1)}${lastMult!==1?` Ã—${lastMult.toFixed(2)}`:''}`;
              frames = 0;
              lastTS = now;
            }
          },
          onAudioSample(l, r) {
            if (warming || isNon1x()) return;
            qL.push(l);
            qR.push(r);
            if (qL.length > MAX_QUEUE) {
              const drop = qL.length - MAX_QUEUE;
              qL.splice(0, drop);
              qR.splice(0, drop);
            }
          }
        });
        audioCtx = new AC();
        mediaDest = audioCtx.createMediaStreamDestination();
        rebuildAudioGraph();
        audioCtx.onstatechange = () => {
          if (audioCtx.state === 'running') rebuildAudioGraph();
        };
        applyScale(2);
      }
      // ------- ä¸»å¾ªç¯ -------
      function loop() {
        try {
          const base = Number(speed) || 1,
            eff = Math.min(6, turboHeld ? base * 2 : base);
          lastMult = eff;
          frameAcc += eff;
          while (frameAcc >= 1) {
            nes.frame();
            frameAcc--;
          }
          pollGamepad(0, padMapP1, padPrevP1, 1);
          pollGamepad(1, padMapP2, padPrevP2, 2);
        } catch (e) {
          pause();
          errEl.textContent = nes.crashMessage || e;
          return;
        }
        rafId = requestAnimationFrame(loop);
      }

      function start() {
        if (running) return;
        running = true;
        errEl.textContent = '';
        audioCtx?.resume?.();
        frames = 0;
        lastTS = performance.now();
        frameAcc = 0;
        rafId = requestAnimationFrame(loop);
        btnStart.textContent = 'æš‚åœ';
        btnReset.disabled = false;
      }

      function pause() {
        if (!running) return;
        running = false;
        if (rafId) cancelAnimationFrame(rafId);
        rafId = null;
        btnStart.textContent = 'å¼€å§‹';
        clearAudioQueue();
        releaseAll(1, pressedP1);
        releaseAll(2, pressedP2);
      }

      function reset() {
        if (!nes) return;
        const was = running;
        if (was) pause();
        clearAudioQueue();
        try {
          if (lastRomU8) nes.loadROM(lastRomU8);
          else if (lastRomStr) nes.loadROM(lastRomStr);
        } catch (e) {
          errEl.textContent = 'Resetå¤±è´¥:' + e;
          return;
        }
        if (was) start();
        else {
          btnReset.disabled = true;
          btnStart.disabled = false;
          btnStart.textContent = 'å¼€å§‹';
        }
      }
      // ------- ROMï¼ˆæœ¬åœ°æ–‡ä»¶ï¼‰ -------
      function loadRomFromFile(file) {
        const r = new FileReader();
        r.onload = ev => {
          const u8 = new Uint8Array(ev.target.result);
          if (!(u8[0] === 0x4E && u8[1] === 0x45 && u8[2] === 0x53 && u8[3] === 0x1A)) {
            errEl.textContent = 'ä¸æ˜¯æœ‰æ•ˆNES ROM';
            return;
          }
          try {
            nes.loadROM(u8);
            lastRomU8 = u8;
            lastRomStr = null;
            afterLoad();
          } catch {
            let s = '';
            for (let i = 0; i < u8.length; i += 0x8000) s += String.fromCharCode.apply(null, u8.subarray(i, i + 0x8000));
            try {
              nes.loadROM(s);
              lastRomU8 = null;
              lastRomStr = s;
              afterLoad();
            } catch (e2) {
              errEl.textContent = 'ROMåŠ è½½å¤±è´¥:' + e2;
            }
          }
        };
        r.readAsArrayBuffer(file);

        function afterLoad() {
          romNameEl.textContent = file.name;
          btnStart.disabled = false;
          btnReset.disabled = true;
          fpsEl.textContent = 'FPS: --';
          errEl.textContent = '';
          start();
          stage.focus();
        }
      }
      // ------- ROMï¼ˆè¿œç¨‹ URLï¼Œä¸€é”®åŠ è½½ï¼‰ -------
      async function loadRomFromUrl(url, displayName) {
        try {
          errEl.textContent = '';
          romNameEl.textContent = 'ä¸‹è½½ä¸­â€¦';
          const res = await fetch(url, {
            cache: 'no-store'
          });
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          const ab = await res.arrayBuffer();
          const u8 = new Uint8Array(ab);
          const isINES = (u8[0] === 0x4E && u8[1] === 0x45 && u8[2] === 0x53 && u8[3] === 0x1A);
          if (!isINES) throw new Error('Not a valid NES ROM (missing iNES header)');
          try {
            nes.loadROM(u8);
            lastRomU8 = u8;
            lastRomStr = null;
          } catch (e1) {
            let s = '';
            const CHUNK = 0x8000;
            for (let i = 0; i < u8.length; i += CHUNK) {
              s += String.fromCharCode.apply(null, u8.subarray(i, i + CHUNK));
            }
            nes.loadROM(s);
            lastRomU8 = null;
            lastRomStr = s;
          }
          romNameEl.textContent = displayName || (url.split('/').pop() || 'ROM');
          btnStart.disabled = false;
          btnReset.disabled = true;
          fpsEl.textContent = 'FPS: --';
          errEl.textContent = '';
          start();
          stage.focus();
        } catch (e) {
          errEl.textContent = 'ROM ä¸‹è½½/åŠ è½½å¤±è´¥ï¼š' + (e?.message || e);
          console.error(e);
        }
      }
      // ------- é”®ç›˜ -------
      function onKey(e, down) {
        if (!nes) return;
        if (e.code === 'Tab') {
          if (down && !turboHeld) {
            turboHeld = true;
            clearAudioQueue();
          } else if (!down && turboHeld) {
            turboHeld = false;
            clearAudioQueue();
          }
          e.preventDefault();
          return;
        }
        for (const [name, code] of Object.entries(keyMapP1)) {
          if (e.code === code) {
            const btn = NES_BUTTONS.find(([n]) => n === name)[1];
            nes[down ? 'buttonDown' : 'buttonUp'](1, btn);
            if (down) pressedP1.add(name);
            else pressedP1.delete(name);
            e.preventDefault();
            return;
          }
        }
        for (const [name, code] of Object.entries(keyMapP2)) {
          if (e.code === code) {
            const btn = NES_BUTTONS.find(([n]) => n === name)[1];
            nes[down ? 'buttonDown' : 'buttonUp'](2, btn);
            if (down) pressedP2.add(name);
            else pressedP2.delete(name);
            e.preventDefault();
            return;
          }
        }
      }

      function releaseAll(player, set) {
        for (const name of set) {
          const btn = NES_BUTTONS.find(([n]) => n === name)[1];
          nes.buttonUp(player, btn);
        }
        set.clear();
        if (player === 1) padPrevP1 = stateObj(false);
        else padPrevP2 = stateObj(false);
      }
      // ------- æ‰‹æŸ„ -------
      function pollGamepad(index, pm, prev, player) {
        const gps = navigator.getGamepads ? navigator.getGamepads() : [];
        const gp = gps && gps[index];
        if (!gp) return;
        const axisH = gp.axes[pm.AXIS_H] ?? 0,
          axisV = gp.axes[pm.AXIS_V] ?? 0,
          th = Math.max(0.2, Math.min(1, pm.AXIS_THRESH || 0.4));
        const useDpad = [pm.DPAD_UP, pm.DPAD_DOWN, pm.DPAD_LEFT, pm.DPAD_RIGHT].every(Number.isInteger);
        const now = {
          LEFT: useDpad ? btnPressed(gp, pm.DPAD_LEFT) : (axisH < -th),
          RIGHT: useDpad ? btnPressed(gp, pm.DPAD_RIGHT) : (axisH > th),
          UP: useDpad ? btnPressed(gp, pm.DPAD_UP) : (axisV < -th),
          DOWN: useDpad ? btnPressed(gp, pm.DPAD_DOWN) : (axisV > th),
          A: btnPressed(gp, pm.BTN_A) || btnPressed(gp, pm.ALT_A),
          B: btnPressed(gp, pm.BTN_B) || btnPressed(gp, pm.ALT_B),
          SELECT: btnPressed(gp, pm.BTN_SELECT),
          START: btnPressed(gp, pm.BTN_START),
        };
        for (const [name, pressed] of Object.entries(now)) {
          if (pressed !== prev[name]) {
            const btn = NES_BUTTONS.find(([n]) => n === name)[1];
            nes[pressed ? 'buttonDown' : 'buttonUp'](player, btn);
            prev[name] = pressed;
          }
        }
      }

      function btnPressed(gp, idx) {
        const b = gp.buttons[idx];
        return !!(b && b.pressed);
      }
      // ------- æˆªå›¾/å½•åˆ¶ -------
      function screenshot() {
        const a = document.createElement('a');
        a.href = canvas.toDataURL('image/png');
        a.download = (romNameEl.textContent || 'shot') + '.png';
        a.click();
      }

      function setupRecorder() {
        try {
          const cs = canvas.captureStream(60);
          mediaStream = new MediaStream([...cs.getVideoTracks(), ...mediaDest.stream.getAudioTracks()]);
          recorder = new MediaRecorder(mediaStream, {
            mimeType: 'video/webm;codecs=vp9,opus'
          });
          recorder.ondataavailable = e => {
            if (e.data.size) recChunks.push(e.data);
          };
          recorder.onstop = () => {
            const url = URL.createObjectURL(new Blob(recChunks, {
              type: 'video/webm'
            }));
            recChunks = [];
            recDL.href = url;
            recDL.style.display = 'inline-block';
          };
        } catch (e) {
          alert('æµè§ˆå™¨ä¸æ”¯æŒå½•åˆ¶ï¼š' + e);
        }
      }
      // ====== å­˜æ¡£ï¼ˆå« ROM + è®¾ç½®ï¼‰======
      function currentSettings() {
        return {
          keyMapP1,
          keyMapP2,
          padMapP1,
          padMapP2,
          swapRB,
          volume,
          muted,
          scale: Number(scaleSel.value) || 2,
          speed: Number(speedSel.value) || 1,
          crt: document.getElementById('crt').classList.contains('on'),
        };
      }

      function applySettings(s) {
        try {
          if (!s) return;
          if (s.keyMapP1) {
            keyMapP1 = s.keyMapP1;
            saveJSON('jsnes_keymap_p1', keyMapP1);
          }
          if (s.keyMapP2) {
            keyMapP2 = s.keyMapP2;
            saveJSON('jsnes_keymap_p2', keyMapP2);
          }
          if (s.padMapP1) {
            padMapP1 = s.padMapP1;
            saveJSON('jsnes_padmap_p1', padMapP1);
          }
          if (s.padMapP2) {
            padMapP2 = s.padMapP2;
            saveJSON('jsnes_padmap_p2', padMapP2);
          }
          if (typeof s.swapRB === 'boolean') {
            swapRB = s.swapRB;
            document.getElementById('swap').classList.toggle('on', swapRB);
          }
          if (typeof s.volume === 'number') {
            volume = Math.max(0, Math.min(1, s.volume));
            volEl.value = Math.round(volume * 100);
          }
          if (typeof s.muted === 'boolean') {
            muted = s.muted;
            btnMute.classList.toggle('on', muted);
            btnMute.textContent = muted ? 'ğŸ”‡ å·²é™éŸ³' : 'ğŸ”ˆ é™éŸ³';
          }
          if (typeof s.scale === 'number') applyScale(s.scale);
          if (typeof s.speed === 'number') {
            speed = s.speed;
            speedSel.value = String(s.speed);
          }
          const crtOn = !!s.crt;
          document.getElementById('crt').classList.toggle('on', crtOn);
          stage.classList.toggle('crt', crtOn);
        } catch (e) {
          console.warn('applySettings error', e);
        }
      }

      function saveState() {
        try {
          const core = nes.toJSON?.();
          if (!core) return alert('å½“å‰æ„å»ºä¸æ”¯æŒä¿å­˜');
          const romU8 = lastRomU8 ? lastRomU8 :
            (lastRomStr ? binStrToU8(lastRomStr) : null);
          const romHash = romU8 ? fnv1aHex(romU8) : null;
          const romName = romNameEl.textContent || '';
          const payload = {
            version: 2,
            createdAt: Date.now(),
            meta: {
              romName,
              romHash,
              settings: currentSettings()
            },
            romU8: romU8 ? u8ToBase64(romU8) : null,
            nesState: core
          };
          try {
            localStorage.setItem(STATE_PREFIX + slotSel.value, JSON.stringify(payload));
            toast(`å·²ä¿å­˜åˆ°æ§½ #${+slotSel.value+1}${!payload.romU8?'ï¼ˆæœªæºå¸¦ROMï¼‰':''}`);
          } catch (e) {
            console.warn('ä¿å­˜è¶…å‡ºå®¹é‡ï¼Œå›é€€ä¸ºç²¾ç®€å­˜æ¡£', e);
            payload.romU8 = null;
            localStorage.setItem(STATE_PREFIX + slotSel.value, JSON.stringify(payload));
            toast(`å®¹é‡ä¸è¶³ï¼Œå·²ä»¥ç²¾ç®€æ¨¡å¼ä¿å­˜åˆ°æ§½ #${+slotSel.value+1}`);
          }
        } catch (e) {
          alert('ä¿å­˜å¤±è´¥ï¼š' + e);
        }
      }

      function loadState() {
        try {
          const raw = localStorage.getItem(STATE_PREFIX + slotSel.value);
          if (!raw) return alert('æ­¤æ§½æ²¡æœ‰å­˜æ¡£');
          const payload = JSON.parse(raw);
          const wantU8 = payload.romU8 ? base64ToU8(payload.romU8) : null;
          const wantHash = payload.meta?.romHash || null;
          const currU8 = lastRomU8 ? lastRomU8 : (lastRomStr ? binStrToU8(lastRomStr) : null);
          const currHash = currU8 ? fnv1aHex(currU8) : null;
          if (wantU8 && (!currHash || currHash !== wantHash)) {
            try {
              nes.loadROM(wantU8);
              lastRomU8 = wantU8;
              lastRomStr = null;
              romNameEl.textContent = payload.meta?.romName || 'From Save';
            } catch (e) {
              console.warn('åˆ‡æ¢åˆ°å­˜æ¡£å†…ROMå¤±è´¥ï¼Œå°è¯•å­—ç¬¦ä¸²å›é€€', e);
              const asStr = u8ToBinStr(wantU8);
              nes.loadROM(asStr);
              lastRomU8 = null;
              lastRomStr = asStr;
              romNameEl.textContent = payload.meta?.romName || 'From Save';
            }
          }
          applySettings(payload.meta?.settings);
          if (!nes.fromJSON) return alert('å½“å‰æ„å»ºä¸æ”¯æŒè¯»å–');
          nes.fromJSON(payload.nesState);
          afterStateRestore();
          toast(`å·²è¯»å–æ§½ #${+slotSel.value+1}`);
        } catch (e) {
          alert('è¯»å–å¤±è´¥ï¼š' + e);
        }
      }

      function clearState() {
        localStorage.removeItem(STATE_PREFIX + slotSel.value);
        toast(`å·²æ¸…é™¤æ§½ #${+slotSel.value+1}`);
      }

      function exportState() {
        try {
          const core = nes.toJSON?.();
          if (!core) return alert('å½“å‰æ„å»ºä¸æ”¯æŒå¯¼å‡º');
          const romU8 = lastRomU8 ? lastRomU8 : (lastRomStr ? binStrToU8(lastRomStr) : null);
          const romHash = romU8 ? fnv1aHex(romU8) : null;
          const romName = romNameEl.textContent || '';
          const payload = {
            version: 2,
            createdAt: Date.now(),
            meta: {
              romName,
              romHash,
              settings: currentSettings()
            },
            romU8: romU8 ? u8ToBase64(romU8) : null,
            nesState: core
          };
          const b = new Blob([JSON.stringify(payload)], {
            type: 'application/json'
          });
          const a = document.createElement('a');
          const base = (romName || 'state').replace(/\.[^/.]+$/, '');
          a.href = URL.createObjectURL(b);
          a.download = `${base}.state.json`;
          a.click();
        } catch (e) {
          alert('å¯¼å‡ºå¤±è´¥ï¼š' + e);
        }
      }

      function importStateFromFile(f) {
        const r = new FileReader();
        r.onload = ev => {
          try {
            const payload = JSON.parse(ev.target.result);
            const wantU8 = payload.romU8 ? base64ToU8(payload.romU8) : null;
            const wantHash = payload.meta?.romHash || null;
            const currU8 = lastRomU8 ? lastRomU8 : (lastRomStr ? binStrToU8(lastRomStr) : null);
            const currHash = currU8 ? fnv1aHex(currU8) : null;
            if (wantU8 && (!currHash || currHash !== wantHash)) {
              try {
                nes.loadROM(wantU8);
                lastRomU8 = wantU8;
                lastRomStr = null;
              } catch (e) {
                const asStr = u8ToBinStr(wantU8);
                nes.loadROM(asStr);
                lastRomU8 = null;
                lastRomStr = asStr;
              }
              romNameEl.textContent = payload.meta?.romName || f.name.replace(/\.state\.json$/i, '');
            }
            applySettings(payload.meta?.settings);
            if (!nes.fromJSON) return alert('å½“å‰æ„å»ºä¸æ”¯æŒè¯»å–');
            nes.fromJSON(payload.nesState);
            afterStateRestore();
            toast('å·²ä»æ–‡ä»¶å¯¼å…¥å­˜æ¡£');
          } catch (e) {
            alert('å¯¼å…¥å¤±è´¥ï¼š' + e);
          }
        };
        r.readAsText(f);
      }
      // ------- å¤–è§‚ -------
      function applyScale(k) {
        canvas.style.width = 256 * k + 'px';
        canvas.style.height = 240 * k + 'px';
        for (const opt of scaleSel.options) {
          if (+opt.value === k) {
            opt.selected = true;
            break;
          }
        }
      }

      function fitToWindow() {
        const k = Math.max(1, Math.min(Math.floor((innerWidth - 32) / 256), Math.floor((innerHeight - 200) / 240)));
        applyScale(k);
      }
      async function toggleFullscreen() {
        if (document.fullscreenElement) await document.exitFullscreen();
        else await stage.requestFullscreen();
      }
      // ------- å¯è§æ€§æ¢å¤ -------
      document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
          if (running) {
            pausedByVisibility = true;
            pause();
          }
        } else {
          if (pausedByVisibility) {
            pausedByVisibility = false;
            try {
              const p = audioCtx?.resume?.();
              if (p && typeof p.then === 'function') {
                p.then(() => rebuildAudioGraph());
              } else {
                rebuildAudioGraph();
              }
            } catch {
              rebuildAudioGraph();
            }
            frames = 0;
            lastTS = performance.now();
            frameAcc = 0;
            running = true;
            rafId = requestAnimationFrame(loop);
            btnStart.textContent = 'æš‚åœ';
            btnReset.disabled = false;
            btnStart.disabled = false;
            stage.focus();
            if (!warmResumedOnce) {
              warmResumedOnce = true;
              clearAudioQueue();
              warming = true;
              warmUpFrames(24, 6, () => {
                clearAudioQueue();
                warming = false;
              });
            }
          }
        }
      });
      window.addEventListener('pageshow', (e) => {
        if (e.persisted && !running) {
          try {
            const p = audioCtx?.resume?.();
            if (p && typeof p.then === 'function') {
              p.then(() => rebuildAudioGraph());
            } else {
              rebuildAudioGraph();
            }
          } catch {
            rebuildAudioGraph();
          }
          frames = 0;
          lastTS = performance.now();
          frameAcc = 0;
          running = true;
          rafId = requestAnimationFrame(loop);
          btnStart.textContent = 'æš‚åœ';
          btnReset.disabled = false;
          stage.focus();
        }
      });
      window.addEventListener('pagehide', () => {
        if (running) {
          pausedByVisibility = true;
          pause();
        }
      });
      window.addEventListener('focus', () => {
        if (!document.hidden) {
          try {
            const p = audioCtx?.resume?.();
            if (p && typeof p.then === 'function') {
              p.then(() => rebuildAudioGraph());
            } else {
              rebuildAudioGraph();
            }
          } catch {}
        }
      });
      // ------- äº‹ä»¶/UI ç»‘å®š -------
      romInput.onchange = e => {
        const f = e.target.files?.[0];
        if (f) {
          romNameEl.textContent = f.name;
          loadRomFromFile(f);
          stage.focus();
        }
      };
      btnStart.onclick = () => running ? pause() : start();
      btnReset.onclick = reset;
      stage.addEventListener('keydown', e => onKey(e, true));
      stage.addEventListener('keyup', e => onKey(e, false));
      stage.addEventListener('click', () => stage.focus());
      btnMute.onclick = () => {
        muted = !muted;
        btnMute.classList.toggle('on', muted);
        btnMute.textContent = muted ? 'ğŸ”‡ å·²é™éŸ³' : 'ğŸ”ˆ é™éŸ³';
      };
      volEl.oninput = () => {
        volume = Math.max(0, Math.min(1, volEl.value / 100));
      };
      scaleSel.onchange = () => applyScale(Number(scaleSel.value));
      fitBtn.onclick = fitToWindow;
      fsBtn.onclick = toggleFullscreen;
      btnCrt.onclick = () => {
        btnCrt.classList.toggle('on');
        stage.classList.toggle('crt', btnCrt.classList.contains('on'));
      };
      btnSwap.classList.add('on');
      btnSwap.onclick = () => {
        swapRB = !swapRB;
        btnSwap.classList.toggle('on', swapRB);
      };
      btnShot.onclick = screenshot;
      speedSel.onchange = () => {
        speed = Number(speedSel.value) || 1;
        clearAudioQueue();
      }
      document.getElementById('cfgKeysP1').onclick = () => openKeyModal(1);
      document.getElementById('cfgKeysP2').onclick = () => openKeyModal(2);
      restoreKeyDefault.onclick = () => {
        if (keysTitle.dataset.player === '1') {
          keyMapP1 = {
            ...defaultKeyMapP1
          };
          saveJSON('jsnes_keymap_p1', keyMapP1);
        } else {
          keyMapP2 = {
            ...defaultKeyMapP2
          };
          saveJSON('jsnes_keymap_p2', keyMapP2);
        }
        renderKeyGrid(+keysTitle.dataset.player);
      };
      closeKeys.onclick = () => modalKeys.style.display = 'none';

      function openKeyModal(p) {
        keysTitle.textContent = `é”®ç›˜æ˜ å°„ï¼ˆP${p}ï¼‰`;
        keysTitle.dataset.player = String(p);
        renderKeyGrid(p);
        modalKeys.style.display = 'flex';
      }

      function renderKeyGrid(p) {
        keyGrid.innerHTML = '';
        const km = p === 1 ? keyMapP1 : keyMapP2;
        for (const [name] of NES_BUTTONS) {
          const row = document.createElement('div');
          row.className = 'row';
          const l = document.createElement('div');
          l.textContent = name;
          const b = document.createElement('button');
          b.className = 'kbd';
          b.textContent = km[name] || '(æœªè®¾ç½®)';
          b.onclick = () => {
            b.textContent = 'â€¦æŒ‰ä¸€ä¸ªé”®';
            const h = (e) => {
              e.preventDefault();
              km[name] = e.code;
              b.textContent = e.code;
              saveJSON(p === 1 ? 'jsnes_keymap_p1' : 'jsnes_keymap_p2', km);
              window.removeEventListener('keydown', h, true);
            };
            window.addEventListener('keydown', h, true);
          };
          row.appendChild(l);
          row.appendChild(b);
          keyGrid.appendChild(row);
        }
      }
      document.getElementById('cfgPadP1').onclick = () => openPadModal(1);
      document.getElementById('cfgPadP2').onclick = () => openPadModal(2);
      restorePadDefault.onclick = () => {
        if (padTitle.dataset.player === '1') {
          padMapP1 = {
            ...defaultPadMap
          };
          saveJSON('jsnes_padmap_p1', padMapP1);
        } else {
          padMapP2 = {
            ...defaultPadMap
          };
          saveJSON('jsnes_padmap_p2', padMapP2);
        }
        renderPadGrid(+padTitle.dataset.player);
      };
      closePad.onclick = () => modalPad.style.display = 'none';

      function openPadModal(p) {
        padTitle.textContent = `æ‰‹æŸ„æ˜ å°„ï¼ˆP${p} = æ‰‹æŸ„${p-1})`;
        padTitle.dataset.player = String(p);
        renderPadGrid(p);
        modalPad.style.display = 'flex';
      }

      function renderPadGrid(p) {
        padGrid.innerHTML = '';
        const pm = p === 1 ? padMapP1 : padMapP2;
        const items = [
          ['AXIS_H', 'æ°´å¹³è½´ç´¢å¼•', pm.AXIS_H],
          ['AXIS_V', 'å‚ç›´è½´ç´¢å¼•', pm.AXIS_V],
          ['AXIS_THRESH', 'è½´é˜ˆå€¼(0.2~1.0)', pm.AXIS_THRESH],
          ['BTN_A', 'æŒ‰é’® A', pm.BTN_A],
          ['BTN_B', 'æŒ‰é’® B', pm.BTN_B],
          ['ALT_A', 'å¤‡ç”¨ A', pm.ALT_A],
          ['ALT_B', 'å¤‡ç”¨ B', pm.ALT_B],
          ['BTN_SELECT', 'é€‰æ‹©', pm.BTN_SELECT],
          ['BTN_START', 'å¼€å§‹', pm.BTN_START],
          ['DPAD_UP', 'D-Pad ä¸Š', pm.DPAD_UP],
          ['DPAD_DOWN', 'D-Pad ä¸‹', pm.DPAD_DOWN],
          ['DPAD_LEFT', 'D-Pad å·¦', pm.DPAD_LEFT],
          ['DPAD_RIGHT', 'D-Pad å³', pm.DPAD_RIGHT]
        ];
        items.forEach(([key, label, val]) => {
          const row = document.createElement('div');
          row.className = 'row';
          const l = document.createElement('div');
          l.textContent = label;
          const v = document.createElement('span');
          v.className = 'kbd';
          v.textContent = val;
          const b = document.createElement('button');
          b.textContent = 'æ•æ‰';
          b.onclick = () => {
            b.textContent = 'â€¦æŒ‰æ‰‹æŸ„';
            capturePadInput(p - 1, (type, idx, val2) => {
              if (key.startsWith('AXIS')) {
                if (type !== 'axis') return false;
                if (key === 'AXIS_THRESH') pm.AXIS_THRESH = Math.max(0.2, Math.min(1, Math.abs(val2 || 0.4)));
                else if (key === 'AXIS_H') pm.AXIS_H = idx;
                else if (key === 'AXIS_V') pm.AXIS_V = idx;
                v.textContent = (key === 'AXIS_THRESH') ? pm.AXIS_THRESH : idx;
              } else {
                if (type !== 'button') return false;
                pm[key] = idx;
                v.textContent = idx;
              }
              saveJSON(p === 1 ? 'jsnes_padmap_p1' : 'jsnes_padmap_p2', pm);
              b.textContent = 'æ•æ‰';
              return true;
            });
          };
          row.appendChild(l);
          row.appendChild(v);
          row.appendChild(b);
          padGrid.appendChild(row);
        });
        const tip = document.createElement('div');
        tip.className = 'tip';
        tip.textContent = 'æ•æ‰ä¸åˆ°ï¼Ÿå…ˆæŒ‰ä¸€ä¸‹æ‰‹æŸ„ä»»æ„é”®å”¤é†’ï¼›Safari éœ€åœ¨â€œå¼€å§‹â€è¿è¡Œåå†æ•æ‰ã€‚';
        padGrid.appendChild(tip);
      }

      function capturePadInput(padIndex, onPick) {
        const t0 = performance.now();
        (function tick() {
          const gps = navigator.getGamepads ? navigator.getGamepads() : [];
          const gp = gps && gps[padIndex];
          if (gp) {
            for (let i = 0; i < gp.buttons.length; i++) {
              if (gp.buttons[i]?.pressed) {
                if (onPick('button', i, 1)) return;
              }
            }
            let max = 0,
              idx = 0;
            for (let a = 0; a < gp.axes.length; a++) {
              const v = Math.abs(gp.axes[a]);
              if (v > max) {
                max = v;
                idx = a;
              }
            }
            if (max > 0.3) {
              if (onPick('axis', idx, gp.axes[idx])) return;
            }
          }
          if (performance.now() - t0 < 5000) requestAnimationFrame(tick);
        })();
      }
      // æ‹–æ‹½
      ['dragenter', 'dragover'].forEach(ev => window.addEventListener(ev, e => {
        e.preventDefault();
        dropHint.style.display = 'flex';
      }));
      ['dragleave', 'drop'].forEach(ev => window.addEventListener(ev, e => {
        e.preventDefault();
        if (ev === 'drop') return;
        dropHint.style.display = 'none';
      }));
      window.addEventListener('drop', e => {
        dropHint.style.display = 'none';
        const f = e.dataTransfer.files?.[0];
        if (!f) return;
        if (/\.(state\.json|json)$/i.test(f.name)) importStateFromFile(f);
        else if (/\.nes$/i.test(f.name)) {
          romNameEl.textContent = f.name;
          loadRomFromFile(f);
          stage.focus();
        } else alert('ä¸æ”¯æŒçš„æ–‡ä»¶ç±»å‹');
      });
      // å½•åˆ¶
      recStartBtn.onclick = () => {
        if (!recorder) setupRecorder();
        if (!recorder) return;
        recChunks = [];
        recDL.style.display = 'none';
        recorder.start();
        recStartBtn.disabled = true;
        recStopBtn.disabled = false;
      };
      recStopBtn.onclick = () => {
        if (recorder && recorder.state === 'recording') {
          recorder.stop();
          recStartBtn.disabled = false;
          recStopBtn.disabled = true;
        }
      };
      // å­˜æ¡£æŒ‰é’®
      saveBtn.onclick = saveState;
      loadBtn.onclick = loadState;
      clearBtn.onclick = clearState;
      exportBtn.onclick = exportState;
      importInp.onchange = e => {
        const f = e.target.files?.[0];
        if (f) importStateFromFile(f);
        e.target.value = '';
      };
      // ä»£ç†æ‰€æœ‰å¸¦ data-rom-url çš„é“¾æ¥ï¼Œç‚¹å‡»å³å¯åŠ è½½
      document.addEventListener('click', (e) => {
        const a = e.target.closest('[data-rom-url]');
        if (!a) return;
        e.preventDefault();
        const url = a.getAttribute('data-rom-url');
        const name = a.getAttribute('data-rom-name') || a.textContent.trim() || (url.split('/').pop() || 'ROM');
        if (!url) return;
        loadRomFromUrl(url, name);
      });
      // å¯åŠ¨
      init();
      // åœ°å€æ  ?rom=https://... è‡ªåŠ¨åŠ è½½
      (function autoLoadFromQuery() {
        const p = new URLSearchParams(location.search);
        const url = p.get('rom');
        if (url) loadRomFromUrl(url, url.split('/').pop());
      })();
      // ===== å·¥å…·ï¼šå“ˆå¸Œ / ç¼–è§£ç  =====
      function fnv1aHex(u8) {
        let h = 0x811c9dc5 | 0;
        for (let i = 0; i < u8.length; i++) {
          h ^= u8[i];
          h = Math.imul(h, 0x01000193);
        }
        return ('00000000' + (h >>> 0).toString(16)).slice(-8);
      }

      function u8ToBase64(u8) {
        let s = '';
        const CH = 0x8000;
        for (let i = 0; i < u8.length; i += CH) {
          s += String.fromCharCode.apply(null, u8.subarray(i, i + CH));
        }
        return btoa(s);
      }

      function base64ToU8(b64) {
        const s = atob(b64),
          u8 = new Uint8Array(s.length);
        for (let i = 0; i < s.length; i++) u8[i] = s.charCodeAt(i) & 255;
        return u8;
      }

      function binStrToU8(str) {
        const u8 = new Uint8Array(str.length);
        for (let i = 0; i < str.length; i++) u8[i] = str.charCodeAt(i) & 255;
        return u8;
      }

      function u8ToBinStr(u8) {
        let s = '';
        const CH = 0x8000;
        for (let i = 0; i < u8.length; i += CH) {
          s += String.fromCharCode.apply(null, u8.subarray(i, i + CH));
        }
        return s;
      }
    })();
  </script>
</content>


<p> 
  <a href="https://ooyang.cn/tags/game/">#Game</a>
  </p>

  </main>
  <footer>
<small><script src="//cdn.busuanzi.cc/busuanzi/3.6.9/busuanzi.min.js" defer></script>
Total visits:<span id="busuanzi_site_pv">load...</span> | 
Page views:<span id="busuanzi_page_pv">load...</span><br>
Copyright Â© 2025 ooyang.cn</small>

</footer>

</body>
</html>
